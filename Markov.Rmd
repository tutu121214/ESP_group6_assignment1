#Q1-Q3
setwd("C:/Users/HW/Documents/ESP_group6_assignment1")
a <- scan("4300-0.txt",what="character",skip=73,nlines=32858-73,fileEncoding="UTF-8")
a <- gsub("_(","",a,fixed=TRUE) ## remove "_("
a

#define the split_punct function:(Q4)
##marks_position = grep(marks,words,fixed=TRUE)
split_punct <- function(words, marks){

  full_list <- words
  
  for(punc in marks){#Iterate over each element in marks
    full_list_tmp <- full_list
    matches_order <- grep(punc, full_list_tmp, fixed = TRUE)#Find the character position of the corresponding punctuation mark
    marks_len <- length(matches_order)#Number of words with corresponding punctuation marks
    full_list <- rep("",length(full_list_tmp)+marks_len)#Create an empty list that can drop both split words and punctuation.
    f <- matches_order+1:length(matches_order)#f is an indexed list of the original punctuation one position back (where the split punctuation is to be placed)
    full_list[f] <- punc
    full_list[-f] <- gsub(punc,"",full_list_tmp,fixed = TRUE)
  }
  return(full_list)
}

#Q5:Use the function to seperate the punctuation marks from words they are attached to in the text.
marks <- c(".",",",";","!",":","?")
split_punct(a, marks)


#Q6a
a_split <- split_punct(a, marks)
a_lower <- tolower(a_split)
a_lower


a_unique <- unique(a_lower)
a_unique

#Q6b
index_vector <- match(a_lower, a_unique)
index_vector

#Q6c
occur_counts <- tabulate(index_vector)
occur_counts

#Q6d
threshold_search <- function(counts, desired_count) {
  sorted_counts <- sort(counts, decreasing = TRUE)
  return(sorted_counts[desired_count])
}

threshold <- threshold_search(occur_counts, 1000)
threshold

#Q6e
common_words <- a_unique[occur_counts >= threshold]
common_words

#Q7a
a_lower_2 <- match(a_lower, common_words)
a_lower_2

#Q7b
mlag <- 4
n <- length(a_lower)
M <- matrix(NA, n - mlag, mlag+1)

for(i in 1:(mlag+1)){
  M[,i] <- a_lower_2[i:(n-mlag+i-1)]
}
M


#Q8
simulate_text <- function(M, b, nw, mlag) {
# Randomly select the first word from the non-NA word
  current_sequence <- sample(M[!is.na(M[,1]), 1], 1)
  generated_text <- vector("character", nw)
  generated_text[1] <- b[current_sequence]
  
  # Generate the next word
  for (i in 2:nw) {
    next_word_found <- FALSE
    for (j in mlag:1) {
      if (i > j) {
        current_sequence_len <- length(current_sequence)
        compare_len <- min(j, current_sequence_len)
        # Compare rows of M with the current_sequence for the appropriate columns
        matched_rows <- apply(M[, 1:j, drop = FALSE], 1, function(row) {
          all(row == current_sequence[(current_sequence_len - compare_len + 1):current_sequence_len])
        })
        # Find a matching sequence in matrix M
        possible_next_words <- M[matched_rows, (j + 1)]
        possible_next_words <- possible_next_words[!is.na(possible_next_words)]
        if (length(possible_next_words) > 0) {
        # Choose at random from the next possible word
          next_word <- sample(possible_next_words, 1)
          generated_text[i] <- b[next_word]
          if (current_sequence_len == mlag) {
          # If the length is equal to mlag, remove the first word and add the new word
            current_sequence <- c(current_sequence[-1], next_word)
          } else {
          # Otherwise add new words directly
            current_sequence <- c(current_sequence, next_word)
          }
          next_word_found <- TRUE
          break
        }
      }
    }
    # If no matching next word is found, pick a word at random
    if (!next_word_found) {
      generated_text[i] <- sample(b[!is.na(b)], 1)
      next_word <- match(generated_text[i], b)
      current_sequence_len <- length(current_sequence)
      # Determine the length of current_sequence
      if (current_sequence_len == mlag) {
        current_sequence <- c(current_sequence[-1], next_word)
      } else {
        current_sequence <- c(current_sequence, next_word)
      }
    }
  }
  
  return(generated_text)
}

nw <- 50  
mlag <- 4  
generated_text <- simulate_text(M, common_words, nw, mlag)
cat(generated_text, sep = " ")

